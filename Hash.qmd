---
title: "Hash函数"
format: html
jupyter: justcoding
---

## 什么是Hash算法

&emsp;&emsp;根据数据量预先设定一个长度为M的数组，使用一个哈希函数F并以数据的关键字作为自变量，得到唯一的返回值，返回值的范围为0~M-1，这样就可以利用哈希函数F将数据元素映射到数组的某一位下标并把数据存放在对应位置上。查找时，利用哈希函数F计算该数据应该存储在哪里，再到相应的存储位置取出查找的数据。

&emsp;&emsp;例如，有一组数据3、11、8、6需要存储，哈希函数为$F(x)=x\%7$，那么利用哈希函数$F$存储的数据如下表所示。

| 0  | 1  |  2 |  3 |  4 |  5 |  6 | 
|--------|--------|--------| --------| -------- | --------|--------| 
|   | 8   |  | 3 | 11  |   | 6  | 



: 哈希函数示例(第一行是数组的下标，第二行是数据的关键字)


&emsp;&emsp;然而由于关键字的取值可能在一个很大的范围，数据在通过哈希函数进行映射的时候，很难找到一个哈希函数，使得这些关键字不能映射到唯一的值，就会出现多个关键字映射到同一个值的现象，这种现象我们称为冲突。

---

### 链地址法

&emsp;&emsp;链地址法处理冲突的方法本质上是一种数组加链表的处理方法，当发生多个数据通过哈希函数映射后得到相同的哈希值时，通常把具有相同哈希地址的关键字放在同一个链表中，称该链表为同义词链表，该链表也被称为桶。

&emsp;&emsp;当把相同哈希地址的关键字数据都放在同一个链表中时，有 N 个哈希地址就有 N 个链表。同时，用数组 Hash[0..N-1] 存放每个链表的头指针，之后把哈希地址为 i 的数据全部以节点的方式插入对应的链表里，如下图所示。

![](./pics/%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81.png){fig-align="center" width=70%}

&emsp;&emsp;**注意：链地址法本质上是数组+链表的数据结构。**

#### 链地址法的步骤

&emsp;&emsp;链地址法存储数据的过程是这样的，首先建立一个数组 Hash 存储所有链表的头指针，由数据的关键字 Key 通过对应的哈希函数计算出哈希地址，找到相应的桶号，之后建立新的节点存储该数据，并把节点放到桶内链表的最后面或者最前面。

&emsp;&emsp;和存储数据的方法类似，查找数据的时候，也是由数据的关键字通过哈希函数计算关键字对应的哈希地址，之后顺序比较桶的内部节点是否与所查找的关键字一样直到找到数据为止。如果全部节点都不和关键字一样，则说明哈希表里没有该数据。这个解决冲突的方法对哈希函数的要求很高，如果哈希函数选得不太好的话，哈希表的查找效率会退化为链表的查找，也就是顺序查找。

&emsp;&emsp;用链地址法构造的散列表，插入和删除节点操作易于实现，所以构造链表的时间开销很低，但是指针需要开辟额外的地址空间，当数据量很大时，会扩大哈希表规模，内存空间需求较大。

---

## 两个数的和

&emsp;&emsp;给定的一些数字中找出两个数，使得它们的和为N，前提是这些数据中保证有答案，并且只有一个答案。

### 解法一

```{python}
#| echo: true
#| eval: false
def twoSum(nums, target):
    res= []                         #存放结果编号数据
    newnums= nums[:]                #深拷贝，把原数据复制到 newnums 里
    newnums.sort()                  #对新数组排序
    left = 0
    right = len(newnums) - 1        #定义 left 和 right 指针分别指向新数组的开头和结尾
    while left < right:
        if newnums[left] + newnums[right] == target:
            for i in range(0,len(nums)):         #在原始数组中寻找第一个元素的原始下标
                if nums[i] == newnums[left]:
                    res.append(i)                 #将下标加入结果集
                    break
            for i in range(len(nums)-1,-1,-1):    #在原始数组中寻找第二个元素的原始下标
                if nums[i] == newnums[right]:
                    res.append(i)                 #将下标加入结果集
                    break
            res.sort()
            break
        elif newnums[left] + newnums[right] < target:
            left = left + 1                     #让 left 指针向右移动一位
        elif newnums[left] + newnums[right] > target:
            right = right - 1                   #让 right 指针向左移动一位
    return (res[0]+1,res[1]+1)   #返回结果集
```

---

### 解法二
```{python}
def duoSummatio2(nums, target):
    hashmap = {}
    for i in range(len(nums)):
        m=nums[i]
        if target - m in hashmap:
            return [hashmap[target - m], i]
        hashmap[m] = i
```
---

## 单词模式匹配 

```{python}
def wordPattern(pattern, s):
    s = s.split()
    if len(pattern) != len(s):
        return False
    hashmap = {}
    for i in range(len(pattern)):
        if pattern[i] in hashmap:
            if hashmap[pattern[i]] != s[i]:
                return False
        else:
            if s[i] in hashmap.values():
                return False
            hashmap[pattern[i]] = s[i]
    return True 
```

---

## 替换词根

```{python}
from collections import defaultdict

def replace_words(dictionary, sentence):
    root_dict = defaultdict(bool)  # 创建默认返回False的字典
    for root in dictionary:
        root_dict[root] = True     # 将词根标记为True
    
    def replace_word(word):
        for i in range(1, len(word) + 1):
            if root_dict[word[:i]]:  # 检查前缀是否存在
                return word[:i]
        return word
    
    return " ".join(replace_word(word) for word in sentence.split())

# 测试
dictionary = ["cat", "bat", "rat"]
sentence = "the cattle was rattled by the battery"
print(replace_words(dictionary, sentence))
# 输出: the cat was rat by the bat
```
---

## Depth-first Search

&emsp;&emsp;从某个节点 $v$ 出发开始进行搜索，不断搜索直到该节点的所有边都被遍历完。当节点 $v$ 的所有边都被遍历以后，深度优先遍历算法则需要回溯到 $v$ 的前驱节点，来继续搜索这个前驱节点的其他边。

&emsp;&emsp;如果还存在尚未被遍历的节点，则深度优先遍历算法将会按照统一的规则从这些剩下的节点中选择一个节点再重复同样的遍历过程。这样的搜索过程从最开始的节点一直持续到最后一个节点的所有边都遍历完。

### Binary Tree

- Perfect Binary Tree: 每一层的节点都是满的
- Full Binary Tree: 每一个节点都有零或两个子节点，也就是说，没有只有一个子节点的节点。

#### Binary Tree 相关术语

- Degree of a Node: 节点的度是指该节点的子节点的数量。
- Height of a Node: 节点的高度是指从该节点到叶子节点的最长路径上的边的数量。
- Depth of a Node: 节点的深度是指从根节点到该节点的路径上的边的数量。
- parents of a Node: 节点的父节点是指该节点的直接前驱节点。
- children of a Node: 节点的子节点是指该节点的直接后继节点。
- siblings of a Node: 节点的兄弟节点是指具有相同父节点的节点。
- ancestors of a Node: 节点的祖先节点是指从该节点到根节点的路径上的所有节点。
- descendants of a Node: 节点的后代节点是指从该节点到叶子节点的路径上的所有节点。

---
#### 二叉树的遍历方式

1. Pre-order Traversal: 前序遍历是指先访问根节点，然后访问左子树，最后访问右子树。
2. In-order Traversal: 中序遍历是指先访问左子树，然后访问根节点，最后访问右子树。
3. Post-order Traversal: 后序遍历是指先访问左子树，然后访问右子树，最后访问根节点。

---

```{python}
class TreeNode:
    def __init__(self, val: int):
        self.val: int = val # 节点值
        self.height: int = 0 # 节点高度
        self.left: TreeNode | None = None # 左子节点引用
        self.right: TreeNode | None = None # 右子节点引用


def pre_order(root:TreeNode | None):
    if root is None:
        return
    res.append(root)
    pre_order(root=root.left)
    pre_order(root=root.right)
```

#### RDL
```{python}
def in_order(root:TreeNode | None):
    if root is None:
        return
    in_order(root=root.left)
    res.append(root)
    in_order(root=root.right)
```

---

#### LRD
```{python}
def post_order(root:TreeNode | None):
    if root is None:
        return
    post_order(root=root.left)
    post_order(root=root.right)
    res.append(root)
```

---
```{python}
class Node:
    def __init__(self, key):
        self.left = None
        self.right = None
        self.val = key
    def traversePreOrder(self):
        print(self.val, end=' ')
        if self.left:
            self.left.traversePreOrder()
        if self.right:
            self.right.traversePreOrder()
```

### Rob
```{python}
def rob(self, root):
    a = self.helper(root)  # a是一个二维数组，为root的[偷值，不偷值]
    return max(a[0],a[1])  # 返回两个值的最大值，此值为小偷最终获得的财富值。
def helper(self,root):  # 参数为root节点，helper方法输出一个二维数组：root节点的[偷值，不偷值]
    if(root==None):  # 如果root节点为空，输出[0,0]
        return [0,0]
    left = self.helper(root.left)  # left是一个二维数组，为root左侧子节点的[偷值，不偷值]
    right = self.helper(root.right)  # right也是一个二维数组，为root右侧子节点的[偷值，不偷值]
    robValue = root.val + left[1]+ right[1]  # root的偷值
    skipValue = max(left[0],left[1]) + max(right[0],right[1])  # root的不偷值
    return [robValue, skipValue]  # 输出小偷可获得的最大金额
```

#### 多个独立小偷，不能偷相邻节点
```{python}
def rob_multiple_thieves(self, root, thief_count):
    """
    多个小偷合作，但不能偷相邻节点
    每个小偷可以偷任意非相邻节点
    """
    def helper(node):
        if not node:
            # 返回一个列表，dp[i]表示使用i个小偷时的最大收益
            return [0] * (thief_count + 1)
        
        left = helper(node.left)
        right = helper(node.right)
        
        # dp[i] 表示在当前子树中使用i个小偷的最大收益
        dp = [0] * (thief_count + 1)
        
        # 不偷当前节点
        for k in range(thief_count + 1):
            for i in range(k + 1):
                # i个小偷在左子树，k-i个小偷在右子树
                dp[k] = max(dp[k], left[i] + right[k - i])
        
        # 偷当前节点
        rob_dp = [0] * (thief_count + 1)
        if thief_count >= 1:
            rob_dp[1] = node.val  # 至少需要1个小偷来偷当前节点
            for k in range(2, thief_count + 1):
                # 当前节点用1个小偷，剩下的k-1个小偷只能偷不相邻的子树
                max_val = 0
                for i in range(k):
                    # 确保左右子树不包含直接相邻节点
                    max_val = max(max_val, left[i] + right[k - 1 - i])
                rob_dp[k] = node.val + max_val
        
        # 合并两种情况
        result = [0] * (thief_count + 1)
        for k in range(thief_count + 1):
            result[k] = max(dp[k], rob_dp[k])
        
        return result
    
    result = helper(root)
    return max(result)
```

---

### 数组表示二叉树

```{python}
class ArrayBinaryTree:

	def __init__(self, arr: list[int | None]):
		"""构造方法"""
		self._tree = list(arr)

	def size(self):
		"""列表容量"""
		return len(self._tree)

	def val(self, i: int) -> int | None:
		"""获取索引为i 节点的值"""
		# 若索引越界,则返回None ,代表空位
		if i < 0 or i >= self.size():
			return None
		return self._tree[i]

	def left(self, i: int) -> int | None:
		"""获取索引为i 节点的左子节点的索引"""
		return 2 * i + 1

	def right(self, i: int) -> int | None:
		"""获取索引为i 节点的右子节点的索引"""
		return 2 * i + 2

	def parent(self, i: int) -> int | None:
		return (i - 1) // 2

	def level_order(self) -> list[int]:
		self.res = []

		for i in range(self.size()):
			if self.val(i) is not None:
				self.res.append(self.val(i))
		return self.res

	def dfs(self, i: int, order: str):
		if self.val(i) is None:
			return
		# 前序遍历
		if order == "pre":
			self.res.append(self.val(i))
		self.dfs(self.left(i), order)
		# 中序遍历
		if order == "in":
			self.res.append(self.val(i))
		self.dfs(self.right(i), order)
		# 后序遍历
		if order == "post":
			self.res.append(self.val(i))

	def pre_order(self) -> list[int]:
		""" 前序遍历"""
		self.res = []
		self.dfs(0, order="pre")
		return self.res

	def in_order(self) -> list[int]:
		""" 中序遍历"""
		self.res = []
		self.dfs(0, order="in")
		return self.res

	def post_order(self) -> list[int]:
		""" 后序遍历"""
		self.res = []
		self.dfs(0, order="post")
		return self.res

```

---

## Binary Search Tree

1. 对于根节点，左子树中所有节点的值 $<$ 根节点的值 $<$ 右子树中所有节点的值。
2. 任意节点的左、右子树也是二叉搜索树，即同样满足条件1.

![](./pics/binary%20search%20tree.jpeg){fig-align="center" width=100%}

**二叉搜索树的中序遍历序列是升序的！**

二叉搜索树常见应用：

- 用作系统中的多级索引，实现高效的查找、插入、删除操作。
- 作为某些搜索算法的底层数据结构。
- 用于存储数据流，以保持其有序状态。

```{python}
def search(self, num):
    """搜索节点"""
    if self._root is None:
        return None

    cur = self._root
    while cur is not None:
        if cur.val < num:
            cur = cur.right
        elif cur.val > num:
            cur = cur.left
        else:
            return cur  # 找到节点

    return None  # 未找到


def insert(self, num: int):
    if self._root is None:
        self._root = TreeNode(num)
        return
    cur, pre = self._root, Node

    while cur is not None:
        if cur.val == num:
            return
        pre = cur

        if cur.val < num:
            cur = cur.right
        elif cur.val > num:
            cur = cur.left

        node = TreeNode(num)
        if pre.val < num:
            pre.right = node
        else:
            pre.left = node


def delete(self, num):
    if self._root is None:
        self._root = TreeNode(num)

    cur, pre = self._root, None

    while cur is not None:
        if cur.val == num:
            break
        pre = cur

        if cur.val < num:
            cur = cur.right

        else:
            cur = cur.left

    if cur is None:
        return

        # 子节点数量= 0 or 1
        if cur.left is None or cur.right is None:
            # 当子节点数量= 0 / 1 时， child = null / 该子节点
            child = cur.left or cur.right
            # 删除节点cur
            if cur != self._root:
                if pre.left == cur:
                    pre.left = child
                else:
                    pre.right = child
            else:
                # 若删除节点为根节点，则重新指定根节点
                self._root = child
        else:
            tmp: TreeNode = cur.right

            while tmp.left is not None:
                tmp = tmp.left
            self.delete(tmp.val)
            cur.val = tmp.val

```
---

**如何从一组输入数据构建一棵二叉搜索树？根节点的选择是不是很重要？**

&emsp;&emsp;构建树的方法已在二叉搜索树代码中的build_tree() 方法中给出。至于根节点的选择，我们通常会
将输入数据排序，然后将中点元素作为根节点，再递归地构建左右子树。这样做可以最大程度保证树的平衡性。

```{python}
def build_tree(preorder: list[int], inorder: list[int]) -> TreeNode | None:
    inorder_map = {val: i for i, val in enumerate(inorder)}
    root = dfs(preorder, inorder_map, 0, 0, len(inorder) - 1)
    return root

```

---
&emsp;&emsp;广度优先遍历到最底层之前，队列中的节点数量是 $2h$ 吗？

&emsp;&emsp;是的，例如高度 $h = 2$ 的满二叉树，其节点总数 $n = 7$ ，则底层节点数量$4 = 2h = \dfrac{(n+1)}{2}$。

---